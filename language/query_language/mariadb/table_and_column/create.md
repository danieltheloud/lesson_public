# 테이블 생성

- `CREATE TABLE` 키워드를 사용해서, `테이블` 생성할 수 있다.

  ```sql
  CREATE TABLE `스키마 이름`.`테이블 이름`
  (
      열 구조, ...,
      [제약 조건, ...]
  );
  ```

  - `스키마` 이름은 **먼저** 존재해야함에 유의한다.
  - 동일한 `스키마` 내에 동일한 이름의 `테이블`을 만들 수 없음에 유의한다.
- 동일한 `스키마` 내에 이미 존재하는 `테이블`의 이름으로 생성하려고 하면 오류가 발생하므로 유의한다.
  - `IF NOT EXISTS` 키워드를 사용하면, 존재하지 않는 경우에만 생성한다.

  ```sql
  CREATE TABLE IF NOT EXISTS `스키마 이름`.`테이블 이름`
  (
      ...
  );
  ```

## 열

- `열`은 `테이블`에 삽입될 데이터(레코드)의 구조를 지정하기 위해서 존재한다.
- 명명법 : `스네이크 케이스`, `단수형`

### 열 구조

- `열` 구조는 `테이블`에 존재하는 레코드가 가지는 데이터의 타입을 정확하게 제한하기 위해 사용한다.
- `NULL` 또는 `NOT NULL`를 생략하면, `NOT NULL`과 같다.
  > 개발에 혼란을 야기하지 않도록, 생략하지 않는 것을 **추천**한다.
- `NULL`: 해당 열의 값이 비어있을 수 있다는 의미이다.
- `NOT NULL`: 해당 열의 값이 비어있을 수 없다는 의미이다.

  ```sql
  `열 이름` 데이터 타입 [NULL|NOT NULL]
  ```

### 데이터 타입

#### 정수형

- 모든 정수형은 뒤에 `UNSIGNED` 키워드를 추가해서 음수부를 포기하고 양수부로 옮겨 사용할 수 있다.
  - 가령 `TINYINT UNSIGNED`는 `0`부터 `255`까지의 정수를 담을 수 있게 된다.
- `TINYINT`: (1 Byte) `-128`부터 `127`까지의 정수
- `SMALLINT`: (2 Bytes) `-32,768`부터 `32,767`까지의 정수
- `MEDIUMINT`: (3 Bytes) `-8,388,608`부터 `8,388,607`까지의 정수
- `INT`: (4 Bytes) `-2,147,483,648`부터 `2,147,483,647`까지의 정수
- `BIGINT`: (8 Bytes) `-9,223,372,036,854,775,808`부터 `9,223,372,036,854,775,807`까지의 정수

#### 실수형

- `FLOAT`: (4 Bytes) `-3.402823466E+38`부터 `3.402823466E+38`까지의 부동 소수. 값을 저장하는 방식 때문에 오류가 발생할 수 있어 **실제로 사용하지 않는다**.
- `DOUBLE`: (8 Bytes) `-1.79769313486231517E+308`부터 `1.79769313486231573E+308`까지의 부동 소수. 값을 저장하는 방식 때문에 오류가 발생할 수 있음에 유의한다.
- `DECIMAL(t, p)`: (`t` Bytes) 전체 길이가 `t`, 소수부 길이가 `p`인 고정 소수. 차지하는 용량이 큰 대신, 값이 정확하다.

#### 문자형

- `VARCHAR(n)`: (`n` Bytes ~ `4n` Bytes) 문자를 담기 위해 사용한다. 최대 `n`개의 문자를 담을 수 있다. 최대 `65,535`자.
- `TINYTEXT(n)`: (`n` Bytes ~ `4n` Bytes) 문자를 담기 위해 사용한다. 최대 `n`개의 문자를 담을 수 있다. 최대 `255`자.
- `TEXT(n)`: (`n` Bytes ~ `4n` Bytes) 문자를 담기 위해 사용한다. 최대 `n`개의 문자를 담을 수 있다. 최대 `65,535`자.
- `MEDIUMTEXT(n)`: (`n` Bytes ~ `4n` Bytes) 문자를 담기 위해 사용한다. 최대 `n`개의 문자를 담을 수 있다. 최대 `16,777,215`자.
- `LONGTEXT(n)`: (`n` Bytes ~ `4n` Bytes) 문자를 담기 위해 사용한다. 최대 `n`개의 문자를 담을 수 있다. 최대 `4,294,967,295`자.

#### 논리형

- `BOOLEAN`: 참(`TRUE`)과 거짓(`FALSE`)을 가질 수 있다.

#### 날짜 및 시간

- `DATE`: 날짜(년, 월, 일)을 가질 수 있다.
- `TIME`혹은 `TIME(n)`: 시간(시, 분, 초)을 가질 수 있다. `n`은 마이크로초의 길이를 의미한다.
  - 생략 시, 마이크로초를 가지지 않으며, 마이크로초의 최대 길이는 `6`이다.
- `DATETIME`혹은 `DATETIME(n)`: 날짜와 시간을 가질 수 있다. 마찬가지로 `n`은 마이크로초의 길이를 의미한다.
  - 생략 시, 마이크로초를 가지지 않는다.

#### 바이너리형

- `TINYBLOB`: (256 Bytes) 바이너리 파일을 저장하기 위해 사용한다. 최대 `2^8 - 1` 까지의 이진수를 담을 수 있다.
- `BLOB`: (64 KB) 바이너리 파일을 저장하기 위해 사용한다. 최대 `2^16 - 1` 까지의 이진수를 담을 수 있다.
- `MEDIUMBLOB`: (8 MB) 바이너리 파일을 저장하기 위해 사용한다. 최대 `2^24 - 1` 까지의 이진수를 담을 수 있다.
- `LONGBLOB`: (4 GB) 바이너리 파일을 저장하기 위해 사용한다. 최대 `2^32 - 1` 까지의 이진수를 담을 수 있다.

> `BLOB`은 binary large object를 뜻한다.

## 제약조건(constraint)

### 기본키(primary key)

- `PRIMARY KEY` 키워드를 사용해서 `기본키`를 선언할 수 있다.
- `기본키`가 되는 `열`(또는 `열`들)은 해당 `테이블`의 가장 기준이 되는 `열`(또는 `열`들)을 의미한다.
  - `기본키`로 지정된 `열`(또는 `열`들)이 가지는 값에 대해서, 레코드에 직접 접근할 수 있는 주소 값이 메모리상에 캐싱(caching)되므로, 접근 속도가 빨라진다.
  - `기본키`로 지정된 `열`(또는 `열`들)이 가지는 값에 대해서, 레코드들은 중복되는 값을 가질 수 없다.
  - 하나의 `테이블`은 `기본키`를 가지지 않거나, 하나의 `기본키`만 가질 수 있다.
    - 하나의 `기본키`가 여러개의 `열`을 가질수는 있지만, 여러개의 `기본키`가 존재할 수는 없다.
- `기본키`의 대상이 되는 `열`은 `NULL`을 허용할 수 없다. (`NOT NULL`이어야만 한다.)

  ```sql
  [CONSTRAINT [제약조건 이름]] PRIMARY KEY (`열 이름`, ...)
  ```

### 외래키(foreign key)

- `FOREIGN KEY` 키워드를 사용해서 `외래키`를 선언할 수 있다.
- `외래키`는 현재 `테이블`의 특정 `열`(또는 `열`들)의 값을, 참조(reference) 대상인 `테이블`의 특정 `열`(또는 `열`들)에 이미 존재하는 값이여야만 하도록, 제한하기 위해 사용하는 제약조건이다.
- `피참조 열`은 `기본키`이거나 `고유키`여야 한다.
- `참조 열`과 `피참조 열`의 **데이터 타입**이 같아야 한다.

  ```sql
  [CONSTRAINT [제약조건 이름]] FOREIGN KEY (`참조 열`, ...)
          REFERENCES `피참조 스키마`.`피참조 테이블` (`피참조 열`, ...)
      [ON DELETE CASCADE]
      [ON UPDATE CASCADE]
  ```

  - 참조 관계를 해치지 않기 위해서, `ON DELETE CASCADE` 키워드와 `ON UPDATE CASCADE` 키워드의 사용을 **권장**한다.
    - `ON DELETE CASCADE` 키워드를 사용하면 피참조 대상이 삭제되었을 때, 이를 참조한 레코드도 함께 삭제된다.
    - `ON UPDATE CASCADE` 키워드를 사용하면 피참조 대상이 수정되었을 때, 이를 참조한 레코드도 함께 수정된다.

### 고유키(unique key)

- `UNIQUE` 키워드를 사용해서 `고유키`를 선언할 수 있다.
- `고유키`로 설정된 `열`(또는 `열`들)의 값이 중복되는 레코드는 존재할 수 없다.
- 값이 중복될 수 없다는 점에서 `기본키`와 비슷하다.
  - `고유키`는 하나의 `테이블`에 여러개가 존재할 수 있다는 점이 다르다.
- 기본키는 `NULL`값을 허용하지 않지만 `고유키`는 `NULL`을 허용한다.
  - `NULL`값에 대해서는 중복 검사를 하지 않는다.

  ```sql
  [CONSTRAINT [제약조건 이름]] UNIQUE (`열 이름`, ...)
  ```

### 체크 제약조건(check)

- `CHECK` 키워드를 사용해서 `체크` 조건을 걸어줄 수 있다.

  ```sql
  [CONSTRAINT [제약조건 이름]] CHECK (조건)
  ```
